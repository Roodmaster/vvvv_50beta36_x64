<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.Core</name>
    </assembly>
    <members>
        <member name="T:VL.Core.EventBridge">
            <summary>
            Contains helper functions to turn .NET events into observables.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="T:VL.Core.INotifyHotSwapped">
            <summary>
            Allows objects to get notified when they've been hot swapped.
            </summary>
        </member>
        <member name="M:VL.Core.INotifyHotSwapped.Swapped(System.Object)">
            <summary>
            Called after the object has been replaced by a new instance.
            </summary>
        </member>
        <member name="T:VL.Core.INotifyHotSwapImminent">
            <summary>
            Allows objects which are currently running in the runtime graph to get notified before a hot swap takes place.
            </summary>
        </member>
        <member name="M:VL.Core.INotifyHotSwapImminent.HotSwapImminent">
            <summary>
            Called right before a hot swap will take place.
            </summary>
        </member>
        <member name="T:VL.Core.HotSwapAttribute">
            <summary>
            Forces the hot swapper to call the constructor of this type and only swap fields which also have this attribute set.
            </summary>
        </member>
        <member name="T:VL.Core.RuntimeGraph">
            <summary>
            A collection of methods used by nodes which introduce new entry points into the VL runtime graph.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Enter(VL.Core.INotifyHotSwapImminent)">
            <summary>
            Call when entering the VL runtime graph. Must be followed by a call to Exit.
            </summary>
            <param name="instance">The instance which enters the runtime graph.</param>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Exit(VL.Core.INotifyHotSwapImminent)">
            <summary>
            Call when leaving the VL runtime graph. Must be preceded by a call to Enter.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Pause(System.Int32)">
            <summary>
            Stops instances from entering the VL runtime graph. Must be followed by a call to Continue.
            </summary>
            <param name="millisecondsTimeout">The time in milli seconds to wait for instances to leave the graph.</param>
            <returns>True if no more instances are executing inside the graph.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Continue">
            <summary>
            Continues execution. Must be preceded by a call to Pause.
            </summary>
        </member>
        <member name="P:VL.Core.RuntimeGraph.OnHold">
            <summary>
            Gets or sets whether or not entering in the VL runtime graph is allowed. If true Enter calls will block until set to false.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.GetRunningInstances">
            <summary>
            Gets the instances currently running inside the VL runtime graph.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VL.Core.SafeLazy`1">
            <summary>
            Provides support for lazy initialization with recursive fallback options.
            </summary>
            <typeparam name="T">The type of object that is being lazily initialized.</typeparam>
        </member>
        <member name="M:VL.Core.SafeLazy`1.GetValue(System.Func{`0},System.Func{`0})">
            <summary>
            Gets the lazily initialized value. 
            Will throw a <see cref="T:VL.Core.RecursiveCallException"/> in case the factory call is recursive and <paramref name="recursiveFallback"/> is null.
            If the <paramref name="recursiveFallback"/> is set it will be used to produce an intermediate result instead of throwing the <see cref="T:VL.Core.RecursiveCallException"/>.
            </summary>
            <param name="factory">The factory function to produce the value.</param>
            <param name="recursiveFallback">The fallback function in case the factory call is recursive. If null a <see cref="T:VL.Core.RecursiveCallException"/> will be thrown.</param>
            <returns>The lazily initialized value.</returns>
        </member>
        <member name="T:VL.Core.RecursiveCallException">
            <summary>
            This exception is thrown when the factory function of <see cref="T:VL.Core.SafeLazy`1"/> leads to a recursion.
            </summary>
        </member>
        <member name="T:VL.Core.Properties.Settings">
            <summary>
            Global HDE settings
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.NodeShowImplementationIcon">
            <summary>
            Show the icon for a nodes implementation (patch/code) even for nodes that are not in the &quot;Main&quot; namespace
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.NodeShowType">
            <summary>
            Show a types name in MemberOperation nodes
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.PropertyShowCollectionIcon">
            <summary>
            Display the collection icon for properties whose type is a collection
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.PropertyShowMutableIcon">
            <summary>
            Display the mutable icon for properties whose type is mutable
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.RuntimeSupport">
            <summary>
            When enabled values as well as timing information can be inspected at runtime. Has minor impact on performance however.
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowDocumentation">
            <summary>
            Display code documentation 
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowLocalID">
            <summary>
            Display an items localID
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowOperation">
            <summary>
            Display the Operation an item is part of 
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.MouseWheelZooms">
            <summary>
            Mouse wheel zooms, + ALT pans vertically, + SHIFT pans horizontally. Otherwise mouse wheel pans vertically, + CTRL zooms
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.RuntimeDisableJITOptimizations">
            <summary>
            Disables JIT optimizations for dynamically emitted assemblies. Should a runtime exception occur the nodes colored red should always match the stack trace.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.FrameClock">
            <summary>
            The clock used to determine the time when the current frame of the vl mainloop started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentFrameTime">
            <summary>
            The time when the current frame started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.RealTimeClock">
            <summary>
            The clock used to determine the current time, returns a new time value for each call
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentTime">
            <summary>
            Checks time now
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTime(System.DateTime)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTimeUTC(System.DateTimeOffset)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Value">
            <summary>
            Gets the current enum value as string
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Tag">
            <summary>
            Gets the associated tag if the enum definition has registered one.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnum.CreateValue(System.String)">
            <summary>
            Creates a new enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Default">
            <summary>
            Creates the default enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Definition">
            <summary>
            Gets the definition of this enum with all entries
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.OnChange">
            <summary>
            Fires when the definition changes, i.e. entries get added or removed
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.Entries">
            <summary>
            Gets the current list of valid entries
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnumDefinition.IsValid(System.String)">
            <summary>
            Returns true if the string is a valid entry of this enum type
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.EmptyEnumFallbackMessage">
            <summary>
            Gets the empty enum fallback string for cases when no entries are in the enum definition.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.IsValid(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Returns true if the value is in the current entry list of the definition.
            </summary>
            <returns>
              <c>true</c> if the specified input is valid, not null and its value is not a null or empty string; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.SelectedIndex(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Gets the index of the selected item in the entries list of its definition.
            Can return -1 if the string is not in the current list of entries.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.CreateValue``1(``0,System.String)">
            <summary>
            Creates a new enum value of given type
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.TrySelectIndex``1(``0,System.Int32,System.Boolean@,``0@)">
            <summary>
            Sets the selected item to the value at the index in the entries list of its definition.
            If the index is out of range, returns false and the input value.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumBase`2">
            <summary>
            Base class for easy dynamic enum implementaion. Use like this:
            MyEnumClass : DynamicEnumBase&lt;MyEnumClass&gt; and override 
            IDynamicEnumDefinition Definition { get; } and define a default value:
            public static MidiInputDevice Default => new MyEnumClass("Default Entry");
            <typeparam name="TSubclass">The type of the actual dynamic enum class.</typeparam>
            <typeparam name="TDefinitionClass">The type of the enum definition.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnum" />
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumBase`2.CreateDefaultBase(System.String)">
            <summary>
            Can be used in subclass to create the default, selects the first entry.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumDefinitionBase`1">
            <summary>
            Base class for dynamic enum definitions.
            Takes care of the singleton pattern and the update of the entries. Use like this:
            MyEnumDefinitionClass : DynamicEnumBase&lt;MyEnumDefinitionClass&gt; and override the two abstract methods.
            <typeparam name="TDefinitionSubclass">The type of the actual definition class.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnumDefinition" />
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the item at specified index
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at specified index
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.CopyTo(`0[],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies 'Count' elements from 'Start Index' to an Array at the 'Array Index' position
            </summary>
            <param name="array"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="arrayIndex"></param>
            <param name="reverseOrder"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort">
            <summary>
            Sorts the elements in the entire spread builder using the default comparer
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort(System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the elements in the entire spread builder using the specified comparer function
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.ToBuilder">
            <summary>
            Creates a spread builder with the same contents as this spread that can be efficiently modified across multiple operations
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.IsEmpty">
            <summary>
            Whether or not the spread is empty
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Count">
            <summary>
            Returns the number of slices in the spread
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Item(System.Int32)">
            <summary>
            Returns the item at the specified index. Can throw ArgumentOutOfRangeException exception
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns the index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.Pin">
            <summary>
            Pins the internal data array of the spread on the garbage collector to access it from unmanaged code.
            Use at your own risk, i.e. never modify bytes in it. Also make sure Unpin gets called to avoid memory leaks.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.Unpin">
            <summary>
            Frees the pinned garbage collector handle, if allocated.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.Spread">
            <summary>
            Contains all those methods which are used in C# and VL.
            Methods which are only used in VL reside in SpreadNodes.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.SizeInBytes``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            The size in bytes = element type size * count.
            Returns IntPtr * count for reference types.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.GetInternalArray``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            Gets the internal data array of the spread, use at your own risk, i.e. never modify it.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageExtensions.Default">
            <summary>
            A white one by one pixel RGBA image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(``0[],System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.Boolean)">
            <summary>
            Makes the array accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the data array gets modified later.</param>
            <returns>An image which uses the array as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(VL.Lib.Collections.Spread{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat)">
            <summary>
            Makes the spread accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <returns>An image which uses the spread as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.Drawing.Bitmap,System.Boolean,System.Boolean)">
            <summary>
            Makes the bitmap accessible as an image. No data gets copied.
            </summary>
            <param name="bitmap">The bitmap to wrap.</param>
            <param name="takeOwnership">Whether or not the wrapper should take ownership of the bitmap. So in case it gets disposed the bitmap will also get disposed.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the bitmap gets modified later.</param>
            <returns>The image wrapping the bitmap.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.IntPtr,System.Int32,System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the pointer accessible as an image. No data gets copied. The returned image is volatile and should get disposed of.
            Once disposed further access to <see cref="M:VL.Lib.Basics.Imaging.IImage.GetData"/> will return the image data from the default image.
            </summary>
            <param name="pointer">The pointer to the data of the image.</param>
            <param name="size">The size in bytes of the image data.</param>
            <param name="width">The width in pixel.</param>
            <param name="height">The height in pixel.</param>
            <param name="format">The pixel format.</param>
            <param name="originalFormat">The original pixel format. Can be null.</param>
            <returns>A volatile image using the pointer as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.Clone(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CloneEmpty(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Creates an empty clone of the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>An image of the same size and format but with all pixels set to zero.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ClonePooled(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image. The returned image uses memory from a pool and therefor must be disposed.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image. Ensure it gets disposed.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.ArrayImage{System.Byte}@)">
            <summary>
            Copies the source image to the destination location. If the destination is not yet assigned or if the image
            information doesn't fit a new image will be created and assigned to the destination.
            </summary>
            <param name="src">The image to copy from.</param>
            <param name="dst">The destination location to copy the image to.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToStream(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Makes the image accessible as a stream.
            </summary>
            <param name="image">The image to wrap.</param>
            <returns>A stream which will read from the image.</returns>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ImageInfo">
            <summary>
            A structure containing size information of an image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Width">
            <summary>
            The width of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Height">
            <summary>
            The height of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Format">
            <summary>
            The pixel format of the image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.OriginalFormat">
            <summary>
            The original pixel format as defined by the library the image was loaded from.
            Can be used in case the <see cref="F:VL.Lib.Basics.Imaging.ImageInfo.Format"/> property is set to <see cref="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.#ctor(System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Creates a new instance of the image info structure.
            </summary>
            <param name="width">The width of the image in pixel.</param>
            <param name="height">The height of the image in pixel.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The pixel format like it was provided by the original library.</param>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.PixelSize">
            <summary>
            The size of a pixel in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ImageSize">
            <summary>
            The size of the image in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ScanSize">
            <summary>
            The size of one scan line (row of pixels) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImage">
            <summary>
            Gives read-only access to images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.Info">
            <summary>
            A structure containing size and format information of the image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.IImage.GetData">
            <summary>
            Gives access to image's data. Must be disposed after being used.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.IsVolatile">
            <summary>
            A volatile image is only valid in the current call stack.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImageData">
            <summary>
            Used for reading images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Pointer">
            <summary>
            The pointer to the data.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Size">
            <summary>
            The data size in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.ScanSize">
            <summary>
            The scan size (one row of pixels) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.PixelFormat">
            <summary>
            An enumeration of commonly used pixel formats.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown">
            <summary>
            Unkown pixel format.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8">
            <summary>
            A single-component, 8-bit unsigned-normalized-integer format that supports 8 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32F">
            <summary>
            A single-component, 32-bit floating-point format that supports 32 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8">
            <summary>
            24-bit RGB pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8X8">
            <summary>
            32-bit RGBx pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8A8">
            <summary>
            32-bit RGBA pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8X8">
            <summary>
            32-bit BGRx pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8A8">
            <summary>
            32-bit BGRA pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32G32B32A32F">
            <summary>
            128-bit RGBA floating point pixel format using 32 bits for each channel.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.UsingAsync``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetch a resource, use it, let it get disposed of when the Task is done.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.ToObservable``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetches a resource and fires a result when the worker task is done. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool. Check the Cancelation token in your worker to stop work if cancelation was requested.
            </summary>        
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceProvider`1">
            <summary>
            Provides an IResourceHandle, which provides access to a Disposable resource.
            Consumers need to dispose these Handles.
            Implementations provide mechanisms for distributing and sharing Disposable resources.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceHandle`1">
            <summary>
            Is returned by IResourceProvider.GetHandle().
            Provides access to a Disposable Resource.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IConnectableResourceProvider`1">
            <summary>
            A connectable resource provider only works after calling Connect. 
            Disconnect via the disposable returned by Connect(). Only then the upstream handle gets disposed of.
            Used to share Resources more efficiently while connected.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooled``2(``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0},System.Action{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Return``1(``0)">
            <summary>
            Will always provide same single resource. It exists already. 
            So its not the responsibility of Return() to dispose it.
            
            Could also imagine a ReturnLazy that takes a Func&lt;TResource&gt;, 
            but as it is used mostly inside the monade it is already lazy to GetHandle() from downstream
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}})">
            <summary>
            SelectMany
            Create a ResourceProvider per source resource. Creating any provider will work.
            Takes into account that the resulting resources may depend on the source resources.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will not get managed as it may exist already. (Select(form => form.Controls[0]) should not dispose the control)
            If you create a new resource that you want to get managed use BindNew for this.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a new resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will get managed.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Do``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Applies an action on a resource and outputs the same resource again.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Where``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Boolean})">
            <summary>
            Just doesn't let you access a resource that doesn't match your needs. Gives you null instead.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.PublishPooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            Manages a pool of handles from the upstream provider.
            On GetHandle, this will return a Handle containing a resource that is not currently in use.
            Manages a pool of upstream handles. When a downstream handle gets disposed, it's inner upstream Handle will be put back into the pool.
            
            Will dispose every upstream handle still in the pool on disconnect.
            Former disposable provider Pool
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``1(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.Int32)">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After delayDisposalInMilliseconds, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``2(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After disposalTriggerSource fired, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Serialize``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Handles get handed out in a serial fashion. Only one handle is in circulation at a given point in time.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32)">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify how long the resource stays valid after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify how long the resource stays valid. 
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify how long the resources in the pool stay valid after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Cata
            Empty using statement
            Only use for sideeffects of the upstream ResourceProvider Monad
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Cata
            Runs the action on the resource
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Cata
            Runs the extractor on the resource and returns the output.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``3(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},System.Func{``0,``1,``2})">
            <summary>
            Return a resource using two source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Return a resource using three source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Return a resource using four source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Create a new resource using three source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Create a new resource using four source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Handle`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Provider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.ConnectableProvider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable returned by Connect().
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.GetLatestResourceForTemporaryUse`1">
            <summary>
            Takes a resourceprovider and outputs its resource
            Makes sure to call GetHandle before releasing the old handle.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsFile">
            <summary>
            Returns whether the path is a file
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsDirectory">
            <summary>
            Returns whether the path is a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Size">
            <summary>
            Returns the size of a file or all the files in a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Exists">
            <summary>
            Returns whether file or folder exists
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.Refresh">
            <summary>
            Updates all properties of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.IO.Path.Parent">
            <summary>
            For a directory returns its parent directory. For a file returns the directory the file is in
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDescendants(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files and folders contained withinin a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDirectories(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all folders contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetFiles(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.Filename(VL.Lib.IO.Path@,System.String@,System.String@)">
            <summary>
            Returns the directory path and the name and extension of a file
            </summary>
            <param name="directory"></param>
            <param name="filename"></param>
            <param name="extension"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.GetAttributes(System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Returns readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.SetAttributes(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.Modified(System.DateTime@,System.DateTime@,System.DateTime@)">
            <summary>
            Returns creation date, last write and last access dates of a file or folder
            </summary>
            <param name="creationTime"></param>
            <param name="lastWriteTime"></param>
            <param name="lastAccessTime"></param>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.Permutations``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            (a,b),(c,d) -> (a,c),(a,d),(b,c),(b,d)
            </summary>
        </member>
    </members>
</doc>
